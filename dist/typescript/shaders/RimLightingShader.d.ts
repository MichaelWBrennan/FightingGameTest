/**
 * Rim Lighting Shader for HD-2D Character Depth
 * Provides Octopath Traveler-style rim lighting on 2D sprites
 * Converted from GLSL to TypeScript
 */
export declare class RimLightingShader {
    static readonly vertexShader = "\n    // ========== VERTEX SHADER ==========\n    attribute vec3 vertex_position;\n    attribute vec2 vertex_texCoord0;\n    attribute vec3 vertex_normal;\n\n    uniform mat4 matrix_model;\n    uniform mat4 matrix_view;\n    uniform mat4 matrix_projection;\n    uniform mat4 matrix_normal;\n\n    // Camera and lighting uniforms\n    uniform vec3 view_position;\n    uniform vec3 light_globalAmbient;\n\n    // Rim lighting parameters\n    uniform float rimPower;\n    uniform float rimIntensity;\n    uniform vec3 rimColor;\n\n    // Output to fragment shader\n    varying vec2 vUv0;\n    varying vec3 vWorldPosition;\n    varying vec3 vWorldNormal;\n    varying vec3 vViewDirection;\n    varying float vRimFactor;\n\n    void main(void) {\n        // Transform vertex position\n        vec4 worldPosition = matrix_model * vec4(vertex_position, 1.0);\n        vWorldPosition = worldPosition.xyz;\n        \n        // Transform normal to world space\n        vWorldNormal = normalize((matrix_normal * vec4(vertex_normal, 0.0)).xyz);\n        \n        // Calculate view direction\n        vViewDirection = normalize(view_position - vWorldPosition);\n        \n        // Calculate rim lighting factor in vertex shader for smooth interpolation\n        float rimDot = 1.0 - dot(vViewDirection, vWorldNormal);\n        vRimFactor = pow(smoothstep(0.0, 1.0, rimDot), rimPower);\n        \n        // Pass texture coordinates\n        vUv0 = vertex_texCoord0;\n        \n        // Final vertex position\n        gl_Position = matrix_projection * matrix_view * worldPosition;\n    }\n  ";
    static readonly fragmentShader = "\n    // ========== FRAGMENT SHADER ==========\n    #ifdef GL_ES\n    precision highp float;\n    #endif\n\n    // Input from vertex shader\n    varying vec2 vUv0;\n    varying vec3 vWorldPosition;\n    varying vec3 vWorldNormal;\n    varying vec3 vViewDirection;\n    varying float vRimFactor;\n\n    // Texture uniforms\n    uniform sampler2D texture_diffuseMap;\n    uniform sampler2D texture_normalMap;\n\n    // Material properties\n    uniform vec3 material_diffuse;\n    uniform vec3 material_emissive;\n    uniform float material_opacity;\n\n    // Lighting uniforms\n    uniform vec3 light_globalAmbient;\n    uniform vec3 light_color;\n    uniform vec3 light_direction;\n    uniform float light_intensity;\n\n    // Rim lighting parameters\n    uniform float rimPower;\n    uniform float rimIntensity;\n    uniform vec3 rimColor;\n    uniform float rimBlend;\n\n    // HD-2D specific parameters\n    uniform float depthBlur;\n    uniform float pixelSize;\n    uniform vec2 screenResolution;\n\n    // Fighting game specific\n    uniform float hitFlash;\n    uniform vec3 hitFlashColor;\n    uniform float characterHighlight;\n\n    // Utility functions\n    vec3 getNormalFromMap(vec2 uv, vec3 worldPos, vec3 worldNormal) {\n        vec3 tangentNormal = texture2D(texture_normalMap, uv).xyz * 2.0 - 1.0;\n        \n        vec3 Q1 = dFdx(worldPos);\n        vec3 Q2 = dFdy(worldPos);\n        vec2 st1 = dFdx(uv);\n        vec2 st2 = dFdy(uv);\n        \n        vec3 N = normalize(worldNormal);\n        vec3 T = normalize(Q1 * st2.t - Q2 * st1.t);\n        vec3 B = -normalize(cross(N, T));\n        mat3 TBN = mat3(T, B, N);\n        \n        return normalize(TBN * tangentNormal);\n    }\n\n    vec3 pixelateColor(vec3 color, float pixelSize) {\n        if (pixelSize <= 0.0) return color;\n        \n        // Quantize color for pixel art effect\n        return floor(color * pixelSize) / pixelSize;\n    }\n\n    void main(void) {\n        // Sample base diffuse texture\n        vec4 baseColor = texture2D(texture_diffuseMap, vUv0);\n        vec3 diffuse = baseColor.rgb * material_diffuse;\n        \n        // Get normal (use normal map if available)\n        vec3 normal = vWorldNormal;\n        #ifdef NORMALMAP\n            normal = getNormalFromMap(vUv0, vWorldPosition, vWorldNormal);\n        #endif\n        \n        // Calculate basic lighting\n        float lightDot = max(dot(normal, -light_direction), 0.0);\n        vec3 lightColor = light_color * light_intensity * lightDot;\n        \n        // Calculate rim lighting\n        float rimFactor = vRimFactor;\n        \n        // Enhanced rim calculation for HD-2D effect\n        float fresnel = pow(1.0 - dot(vViewDirection, normal), rimPower);\n        fresnel = smoothstep(0.0, 1.0, fresnel);\n        \n        // Combine rim factors\n        rimFactor = max(rimFactor, fresnel) * rimIntensity;\n        \n        // Apply rim color\n        vec3 rimContribution = rimColor * rimFactor;\n        \n        // Combine lighting\n        vec3 ambient = light_globalAmbient * diffuse;\n        vec3 finalColor = ambient + diffuse * lightColor + rimContribution;\n        \n        // Apply emissive\n        finalColor += material_emissive;\n        \n        // Character highlight effect (for special moves, selection, etc.)\n        if (characterHighlight > 0.0) {\n            vec3 highlightColor = vec3(1.2, 1.1, 1.0);\n            finalColor = mix(finalColor, finalColor * highlightColor, characterHighlight);\n        }\n        \n        // Hit flash effect (for impact feedback)\n        if (hitFlash > 0.0) {\n            finalColor = mix(finalColor, hitFlashColor, hitFlash);\n        }\n        \n        // Depth-based blur simulation (simple desaturation)\n        if (depthBlur > 0.0) {\n            float luminance = dot(finalColor, vec3(0.299, 0.587, 0.114));\n            finalColor = mix(finalColor, vec3(luminance), depthBlur * 0.5);\n        }\n        \n        // Pixel art preservation\n        if (pixelSize > 0.0) {\n            finalColor = pixelateColor(finalColor, pixelSize);\n        }\n        \n        // Apply opacity with alpha testing for sprite edges\n        float alpha = baseColor.a * material_opacity;\n        if (alpha < 0.1) discard;\n        \n        gl_FragColor = vec4(finalColor, alpha);\n    }\n  ";
    static createMaterial(device: any): any;
    static setUniforms(material: any, params: {
        viewPosition: [number, number, number];
        globalAmbient: [number, number, number];
        rimPower: number;
        rimIntensity: number;
        rimColor: [number, number, number];
        lightColor: [number, number, number];
        lightDirection: [number, number, number];
        lightIntensity: number;
        materialDiffuse: [number, number, number];
        materialEmissive: [number, number, number];
        materialOpacity: number;
        depthBlur: number;
        pixelSize: number;
        screenResolution: [number, number];
        hitFlash: number;
        hitFlashColor: [number, number, number];
        characterHighlight: number;
    }): void;
}
