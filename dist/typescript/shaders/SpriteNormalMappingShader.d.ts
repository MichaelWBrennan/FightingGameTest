/**
 * Sprite Normal Mapping Shader for HD-2D 2D Sprites
 * Adds depth and lighting to flat 2D character sprites using normal maps
 * Converted from GLSL to TypeScript
 */
export declare class SpriteNormalMappingShader {
    static readonly vertexShader = "\n    // ========== VERTEX SHADER ==========\n    attribute vec3 vertex_position;\n    attribute vec2 vertex_texCoord0;\n    attribute vec3 vertex_normal;\n    attribute vec3 vertex_tangent;\n\n    uniform mat4 matrix_model;\n    uniform mat4 matrix_view;\n    uniform mat4 matrix_projection;\n    uniform mat4 matrix_normal;\n\n    // Camera position\n    uniform vec3 view_position;\n\n    // Light positions (multiple lights for HD-2D)\n    uniform vec3 light_position_0;\n    uniform vec3 light_position_1;\n    uniform vec3 light_position_2;\n\n    // Output to fragment shader\n    varying vec2 vUv0;\n    varying vec3 vWorldPosition;\n    varying vec3 vWorldNormal;\n    varying vec3 vWorldTangent;\n    varying vec3 vWorldBitangent;\n    varying vec3 vViewDirection;\n\n    // Light directions in tangent space\n    varying vec3 vLightDirection0_TS;\n    varying vec3 vLightDirection1_TS;\n    varying vec3 vLightDirection2_TS;\n    varying vec3 vViewDirection_TS;\n\n    void main(void) {\n        // Transform vertex to world space\n        vec4 worldPosition = matrix_model * vec4(vertex_position, 1.0);\n        vWorldPosition = worldPosition.xyz;\n        \n        // Transform normal and tangent to world space\n        vWorldNormal = normalize((matrix_normal * vec4(vertex_normal, 0.0)).xyz);\n        vWorldTangent = normalize((matrix_normal * vec4(vertex_tangent, 0.0)).xyz);\n        vWorldBitangent = cross(vWorldNormal, vWorldTangent);\n        \n        // Create tangent-to-world matrix\n        mat3 TBN = mat3(vWorldTangent, vWorldBitangent, vWorldNormal);\n        mat3 worldToTangent = transpose(TBN);\n        \n        // Calculate view direction\n        vViewDirection = normalize(view_position - vWorldPosition);\n        vViewDirection_TS = worldToTangent * vViewDirection;\n        \n        // Calculate light directions in tangent space\n        vec3 lightDir0 = normalize(light_position_0 - vWorldPosition);\n        vec3 lightDir1 = normalize(light_position_1 - vWorldPosition);\n        vec3 lightDir2 = normalize(light_position_2 - vWorldPosition);\n        \n        vLightDirection0_TS = worldToTangent * lightDir0;\n        vLightDirection1_TS = worldToTangent * lightDir1;\n        vLightDirection2_TS = worldToTangent * lightDir2;\n        \n        // Pass texture coordinates\n        vUv0 = vertex_texCoord0;\n        \n        // Final vertex position\n        gl_Position = matrix_projection * matrix_view * worldPosition;\n    }\n  ";
    static readonly fragmentShader = "\n    // ========== FRAGMENT SHADER ==========\n    #ifdef GL_ES\n    precision highp float;\n    #endif\n\n    // Input from vertex shader\n    varying vec2 vUv0;\n    varying vec3 vWorldPosition;\n    varying vec3 vWorldNormal;\n    varying vec3 vWorldTangent;\n    varying vec3 vWorldBitangent;\n    varying vec3 vViewDirection;\n\n    varying vec3 vLightDirection0_TS;\n    varying vec3 vLightDirection1_TS;\n    varying vec3 vLightDirection2_TS;\n    varying vec3 vViewDirection_TS;\n\n    // Texture uniforms\n    uniform sampler2D texture_diffuseMap;\n    uniform sampler2D texture_normalMap;\n    uniform sampler2D texture_specularMap;\n\n    // Material properties\n    uniform vec3 material_diffuse;\n    uniform vec3 material_specular;\n    uniform float material_shininess;\n    uniform float material_opacity;\n\n    // Light properties\n    uniform vec3 light_color_0;\n    uniform vec3 light_color_1;\n    uniform vec3 light_color_2;\n    uniform float light_intensity_0;\n    uniform float light_intensity_1;\n    uniform float light_intensity_2;\n\n    // HD-2D specific parameters\n    uniform float normalMapStrength;\n    uniform float spriteDepth;\n    uniform vec2 spritePixelSize;\n    uniform float pixelPerfect;\n\n    // Fighting game effects\n    uniform float hitFlash;\n    uniform vec3 hitFlashColor;\n    uniform float stunEffect;\n    uniform float counterHitGlow;\n    uniform vec3 playerTint; // P1/P2 color tinting\n\n    // Animation parameters\n    uniform float animationFrame;\n    uniform vec2 spriteSheetSize;\n    uniform vec2 frameSize;\n\n    vec2 getSpriteUV(vec2 baseUV) {\n        if (animationFrame <= 0.0) return baseUV;\n        \n        // Calculate sprite sheet coordinates\n        float frameX = mod(animationFrame, spriteSheetSize.x);\n        float frameY = floor(animationFrame / spriteSheetSize.x);\n        \n        vec2 frameOffset = vec2(frameX, frameY) * frameSize;\n        return frameOffset + baseUV * frameSize;\n    }\n\n    vec3 sampleNormalMap(vec2 uv) {\n        vec3 normal = texture2D(texture_normalMap, uv).rgb;\n        normal = normal * 2.0 - 1.0; // Convert from [0,1] to [-1,1]\n        \n        // Adjust normal map strength for HD-2D effect\n        normal.xy *= normalMapStrength;\n        normal = normalize(normal);\n        \n        return normal;\n    }\n\n    vec3 calculateLighting(vec3 normal, vec3 lightDir, vec3 lightColor, float lightIntensity, vec3 viewDir) {\n        // Diffuse lighting\n        float NdotL = max(dot(normal, lightDir), 0.0);\n        vec3 diffuse = lightColor * lightIntensity * NdotL;\n        \n        // Specular lighting (Blinn-Phong)\n        vec3 halfVector = normalize(lightDir + viewDir);\n        float NdotH = max(dot(normal, halfVector), 0.0);\n        float specularPower = pow(NdotH, material_shininess);\n        vec3 specular = material_specular * lightColor * specularPower * lightIntensity;\n        \n        return diffuse + specular;\n    }\n\n    vec3 applyPixelPerfectFiltering(vec3 color, vec2 uv) {\n        if (pixelPerfect <= 0.0) return color;\n        \n        // Snap UV coordinates to pixel boundaries\n        vec2 pixelUV = floor(uv * spritePixelSize) / spritePixelSize;\n        \n        // Sample with nearest neighbor filtering\n        return texture2D(texture_diffuseMap, pixelUV).rgb * material_diffuse;\n    }\n\n    void main(void) {\n        // Get sprite sheet UV coordinates\n        vec2 spriteUV = getSpriteUV(vUv0);\n        \n        // Sample base diffuse texture\n        vec4 baseColor = texture2D(texture_diffuseMap, spriteUV);\n        vec3 diffuse = baseColor.rgb * material_diffuse;\n        \n        // Early discard for transparent pixels (important for sprites)\n        if (baseColor.a < 0.1) discard;\n        \n        // Sample normal map and convert to tangent space\n        vec3 normalTS = sampleNormalMap(spriteUV);\n        \n        // Sample specular map if available\n        vec3 specularMask = texture2D(texture_specularMap, spriteUV).rgb;\n        \n        // Calculate lighting for each light source\n        vec3 totalLighting = vec3(0.0);\n        \n        // Light 0 (Key light)\n        totalLighting += calculateLighting(\n            normalTS, \n            normalize(vLightDirection0_TS), \n            light_color_0, \n            light_intensity_0,\n            normalize(vViewDirection_TS)\n        );\n        \n        // Light 1 (Fill light)\n        totalLighting += calculateLighting(\n            normalTS, \n            normalize(vLightDirection1_TS), \n            light_color_1, \n            light_intensity_1,\n            normalize(vViewDirection_TS)\n        );\n        \n        // Light 2 (Rim light)\n        totalLighting += calculateLighting(\n            normalTS, \n            normalize(vLightDirection2_TS), \n            light_color_2, \n            light_intensity_2,\n            normalize(vViewDirection_TS)\n        );\n        \n        // Apply specular mask\n        totalLighting *= (1.0 + specularMask * 0.5);\n        \n        // Combine diffuse and lighting\n        vec3 finalColor = diffuse * totalLighting;\n        \n        // Apply player tinting (P1 warm, P2 cool)\n        finalColor = mix(finalColor, finalColor * playerTint, 0.1);\n        \n        // Apply depth-based darkening for sprite layering\n        if (spriteDepth > 0.0) {\n            float depthFactor = 1.0 - spriteDepth * 0.2;\n            finalColor *= depthFactor;\n        }\n        \n        // Fighting game specific effects\n        \n        // Hit flash effect\n        if (hitFlash > 0.0) {\n            finalColor = mix(finalColor, hitFlashColor, hitFlash);\n        }\n        \n        // Stun effect (desaturation + blur simulation)\n        if (stunEffect > 0.0) {\n            float luminance = dot(finalColor, vec3(0.299, 0.587, 0.114));\n            finalColor = mix(finalColor, vec3(luminance), stunEffect * 0.7);\n            \n            // Add slight blue tint for stun\n            finalColor += vec3(0.0, 0.1, 0.2) * stunEffect * 0.3;\n        }\n        \n        // Counter hit glow effect\n        if (counterHitGlow > 0.0) {\n            vec3 glowColor = vec3(1.0, 0.4, 0.4); // Red glow\n            finalColor += glowColor * counterHitGlow * 0.5;\n        }\n        \n        // Pixel perfect rendering option\n        if (pixelPerfect > 0.0) {\n            diffuse = applyPixelPerfectFiltering(diffuse, spriteUV);\n            finalColor = mix(finalColor, diffuse * totalLighting, pixelPerfect);\n        }\n        \n        // Apply opacity\n        float alpha = baseColor.a * material_opacity;\n        \n        gl_FragColor = vec4(finalColor, alpha);\n    }\n  ";
    static createMaterial(device: any): any;
    static setUniforms(material: any, params: {
        viewPosition: [number, number, number];
        lightPosition0: [number, number, number];
        lightPosition1: [number, number, number];
        lightPosition2: [number, number, number];
        lightColor0: [number, number, number];
        lightColor1: [number, number, number];
        lightColor2: [number, number, number];
        lightIntensity0: number;
        lightIntensity1: number;
        lightIntensity2: number;
        materialDiffuse: [number, number, number];
        materialSpecular: [number, number, number];
        materialShininess: number;
        materialOpacity: number;
        normalMapStrength: number;
        spriteDepth: number;
        spritePixelSize: [number, number];
        pixelPerfect: number;
        hitFlash: number;
        hitFlashColor: [number, number, number];
        stunEffect: number;
        counterHitGlow: number;
        playerTint: [number, number, number];
        animationFrame: number;
        spriteSheetSize: [number, number];
        frameSize: [number, number];
    }): void;
}
