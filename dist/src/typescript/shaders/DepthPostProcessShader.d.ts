/**
 * Depth-Based Post-Processing Shader for HD-2D Effects
 * Implements depth-of-field, volumetric fog, and atmospheric effects
 * Converted from GLSL to TypeScript
 */
export declare class DepthPostProcessShader {
    static readonly vertexShader = "\n    // ========== VERTEX SHADER ==========\n    attribute vec3 vertex_position;\n    attribute vec2 vertex_texCoord0;\n\n    uniform mat4 matrix_model;\n    uniform mat4 matrix_view;\n    uniform mat4 matrix_projection;\n\n    varying vec2 vUv0;\n\n    void main(void) {\n        vUv0 = vertex_texCoord0;\n        gl_Position = matrix_projection * matrix_view * matrix_model * vec4(vertex_position, 1.0);\n    }\n  ";
    static readonly fragmentShader = "\n    // ========== FRAGMENT SHADER ==========\n    #ifdef GL_ES\n    precision highp float;\n    #endif\n\n    varying vec2 vUv0;\n\n    // Input textures\n    uniform sampler2D texture_colorBuffer;\n    uniform sampler2D texture_depthBuffer;\n\n    // Screen resolution\n    uniform vec2 uScreenSize;\n    uniform vec2 uInvScreenSize;\n\n    // Camera parameters\n    uniform float uNearClip;\n    uniform float uFarClip;\n    uniform vec3 uCameraPosition;\n    uniform mat4 uViewMatrix;\n    uniform mat4 uProjectionMatrix;\n\n    // Depth-of-field parameters\n    uniform float uFocusDistance;\n    uniform float uFocusRange;\n    uniform float uBokehRadius;\n    uniform float uBokehIntensity;\n    uniform int uDofSamples;\n\n    // Volumetric fog parameters\n    uniform vec3 uFogColor;\n    uniform float uFogDensity;\n    uniform float uFogStart;\n    uniform float uFogEnd;\n    uniform vec3 uLightPosition;\n    uniform vec3 uLightColor;\n    uniform float uLightScattering;\n\n    // HD-2D atmospheric effects\n    uniform float uAtmosphericPerspective;\n    uniform vec3 uAtmosphereColor;\n    uniform float uHeatHaze;\n    uniform float uColorSeparation;\n\n    // Fighting game specific\n    uniform float uScreenShake;\n    uniform vec2 uScreenShakeOffset;\n    uniform float uTimeScale;\n    uniform float uTime;\n\n    // Utility functions\n    float linearizeDepth(float depth) {\n        float z = depth * 2.0 - 1.0; // Convert from [0,1] to [-1,1]\n        return (2.0 * uNearClip * uFarClip) / (uFarClip + uNearClip - z * (uFarClip - uNearClip));\n    }\n\n    float getDepth(vec2 uv) {\n        return linearizeDepth(texture2D(texture_depthBuffer, uv).r);\n    }\n\n    vec3 getWorldPositionFromDepth(vec2 uv, float depth) {\n        vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);\n        vec4 viewSpacePosition = inverse(uProjectionMatrix) * clipSpacePosition;\n        viewSpacePosition /= viewSpacePosition.w;\n        vec4 worldSpacePosition = inverse(uViewMatrix) * viewSpacePosition;\n        return worldSpacePosition.xyz;\n    }\n\n    // Gaussian blur for depth-of-field\n    vec3 gaussianBlur(sampler2D tex, vec2 uv, vec2 direction, float radius, int samples) {\n        vec3 color = vec3(0.0);\n        float totalWeight = 0.0;\n        \n        float step = radius / float(samples);\n        \n        for (int i = -samples; i <= samples; i++) {\n            vec2 offset = direction * step * float(i);\n            vec2 sampleUV = uv + offset * uInvScreenSize;\n            \n            // Check bounds\n            if (sampleUV.x >= 0.0 && sampleUV.x <= 1.0 && sampleUV.y >= 0.0 && sampleUV.y <= 1.0) {\n                float weight = exp(-0.5 * pow(float(i) / float(samples), 2.0));\n                color += texture2D(tex, sampleUV).rgb * weight;\n                totalWeight += weight;\n            }\n        }\n        \n        return color / totalWeight;\n    }\n\n    // Bokeh blur for depth-of-field\n    vec3 bokehBlur(sampler2D tex, vec2 uv, float radius) {\n        vec3 color = vec3(0.0);\n        float totalWeight = 0.0;\n        \n        // Hexagonal bokeh pattern\n        const int samples = 19;\n        const vec2 offsets[19] = vec2[](\n            vec2(0.0, 0.0),\n            vec2(0.0, 1.0), vec2(0.866, 0.5), vec2(0.866, -0.5), \n            vec2(0.0, -1.0), vec2(-0.866, -0.5), vec2(-0.866, 0.5),\n            vec2(0.0, 2.0), vec2(1.732, 1.0), vec2(1.732, -1.0),\n            vec2(0.0, -2.0), vec2(-1.732, -1.0), vec2(-1.732, 1.0),\n            vec2(1.5, 0.866), vec2(1.5, -0.866), vec2(-1.5, -0.866), vec2(-1.5, 0.866),\n            vec2(0.866, 1.5), vec2(-0.866, 1.5)\n        );\n        \n        for (int i = 0; i < samples; i++) {\n            vec2 offset = offsets[i] * radius * uInvScreenSize;\n            vec2 sampleUV = uv + offset;\n            \n            if (sampleUV.x >= 0.0 && sampleUV.x <= 1.0 && sampleUV.y >= 0.0 && sampleUV.y <= 1.0) {\n                float weight = 1.0;\n                if (i > 0) weight = 0.7; // Reduce weight for outer samples\n                \n                color += texture2D(tex, sampleUV).rgb * weight;\n                totalWeight += weight;\n            }\n        }\n        \n        return color / totalWeight;\n    }\n\n    // Calculate depth-of-field blur amount\n    float calculateDofBlur(float depth) {\n        float distance = abs(depth - uFocusDistance);\n        float blur = smoothstep(0.0, uFocusRange, distance);\n        return blur * uBokehRadius;\n    }\n\n    // Volumetric fog calculation\n    vec3 calculateVolumetricFog(vec2 uv, float depth, vec3 worldPos) {\n        // Calculate fog factor based on distance\n        float fogFactor = smoothstep(uFogStart, uFogEnd, depth);\n        fogFactor *= uFogDensity;\n        \n        // Calculate light scattering\n        vec3 lightDir = normalize(uLightPosition - worldPos);\n        vec3 viewDir = normalize(uCameraPosition - worldPos);\n        float scattering = pow(max(dot(lightDir, viewDir), 0.0), 8.0);\n        \n        // Combine fog color with light scattering\n        vec3 fogColorWithLight = mix(uFogColor, uLightColor, scattering * uLightScattering);\n        \n        return fogColorWithLight * fogFactor;\n    }\n\n    // Atmospheric perspective\n    vec3 applyAtmosphericPerspective(vec3 color, float depth) {\n        float atmosphereFactor = smoothstep(10.0, 50.0, depth) * uAtmosphericPerspective;\n        return mix(color, uAtmosphereColor, atmosphereFactor);\n    }\n\n    // Heat haze effect\n    vec2 applyHeatHaze(vec2 uv, float time) {\n        if (uHeatHaze <= 0.0) return uv;\n        \n        float wave1 = sin(uv.y * 30.0 + time * 5.0) * 0.003;\n        float wave2 = sin(uv.y * 45.0 + time * 3.0) * 0.002;\n        \n        return uv + vec2(wave1 + wave2, 0.0) * uHeatHaze;\n    }\n\n    // Chromatic aberration for impact effects\n    vec3 applyChromaticAberration(sampler2D tex, vec2 uv, float amount) {\n        if (amount <= 0.0) return texture2D(tex, uv).rgb;\n        \n        vec2 offset = (uv - 0.5) * amount * 0.01;\n        \n        float r = texture2D(tex, uv + offset).r;\n        float g = texture2D(tex, uv).g;\n        float b = texture2D(tex, uv - offset).b;\n        \n        return vec3(r, g, b);\n    }\n\n    // Screen shake effect\n    vec2 applyScreenShake(vec2 uv) {\n        if (uScreenShake <= 0.0) return uv;\n        \n        vec2 shake = uScreenShakeOffset * uScreenShake * 0.01;\n        return uv + shake;\n    }\n\n    void main(void) {\n        // Apply screen shake\n        vec2 finalUV = applyScreenShake(vUv0);\n        \n        // Apply heat haze\n        finalUV = applyHeatHaze(finalUV, uTime);\n        \n        // Get depth at current pixel\n        float depth = getDepth(finalUV);\n        vec3 worldPos = getWorldPositionFromDepth(finalUV, depth);\n        \n        // Sample base color\n        vec3 color = texture2D(texture_colorBuffer, finalUV).rgb;\n        \n        // Apply chromatic aberration for impact effects\n        if (uColorSeparation > 0.0) {\n            color = applyChromaticAberration(texture_colorBuffer, finalUV, uColorSeparation);\n        }\n        \n        // Calculate depth-of-field\n        float dofBlur = calculateDofBlur(depth);\n        \n        if (dofBlur > 0.1) {\n            // Apply bokeh blur for out-of-focus areas\n            vec3 blurredColor = bokehBlur(texture_colorBuffer, finalUV, dofBlur);\n            color = mix(color, blurredColor, min(dofBlur * uBokehIntensity, 1.0));\n        }\n        \n        // Apply volumetric fog\n        if (uFogDensity > 0.0) {\n            vec3 fogColor = calculateVolumetricFog(finalUV, depth, worldPos);\n            color = mix(color, fogColor, min(uFogDensity, 0.9));\n        }\n        \n        // Apply atmospheric perspective\n        if (uAtmosphericPerspective > 0.0) {\n            color = applyAtmosphericPerspective(color, depth);\n        }\n        \n        // Time-based effects for fighting games\n        if (uTimeScale != 1.0) {\n            // Slow motion effect - enhance clarity\n            color = mix(color, color * 1.1, (1.0 - uTimeScale) * 0.3);\n        }\n        \n        gl_FragColor = vec4(color, 1.0);\n    }\n  ";
    static createMaterial(device: any): any;
    static setUniforms(material: any, params: {
        screenSize: [number, number];
        nearClip: number;
        farClip: number;
        focusDistance: number;
        focusRange: number;
        bokehRadius: number;
        bokehIntensity: number;
        fogColor: [number, number, number];
        fogDensity: number;
        fogStart: number;
        fogEnd: number;
        atmosphericPerspective: number;
        atmosphereColor: [number, number, number];
        heatHaze: number;
        colorSeparation: number;
        screenShake: number;
        screenShakeOffset: [number, number];
        timeScale: number;
        time: number;
    }): void;
}
