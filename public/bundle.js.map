{
  "version": 3,
  "sources": ["../types/playcanvas-shim.ts", "../src/index.ts", "../src/core/GameEngine.ts", "../src/core/characters/CharacterManager.ts", "../src/core/utils/Logger.ts", "../src/core/combat/CombatSystem.ts", "../src/core/stages/StageManager.ts", "../src/core/input/InputManager.ts", "../src/core/ui/UIManager.ts"],
  "sourcesContent": ["// Runtime shim to map module 'playcanvas' imports to the global `pc` provided\n// by the PlayCanvas engine script tag.\n// This is intentionally minimal and relies on the engine being loaded first.\n\nconst pcGlobal: any = (globalThis as any).pc;\n\n// Use CommonJS-style default export so that `import * as pc from 'playcanvas'`\n// receives the entire namespace object across our TypeScript sources.\nexport = pcGlobal;\n\n", "\nimport { GameEngine } from './core/GameEngine';\nimport { Logger } from './core/utils/Logger';\nimport * as pc from 'playcanvas';\n\nasync function defaultStart(canvas: HTMLCanvasElement | null): Promise<void> {\n  const targetCanvas = canvas || (document.getElementById('application-canvas') as HTMLCanvasElement);\n  const engine = new GameEngine(targetCanvas);\n  Logger.info('Starting Street Fighter III: 3rd Strike - PlayCanvas Edition');\n  await engine.initialize();\n\n  const characterManager = engine.getCharacterManager();\n  const ryu = characterManager.createCharacter('ryu', new pc.Vec3(-2, 0, 0));\n  const ken = characterManager.createCharacter('ken', new pc.Vec3(2, 0, 0));\n  if (ryu && ken) {\n    characterManager.setActiveCharacters('ryu', 'ken');\n  }\n}\n\nexport { defaultStart };\n", "\nimport * as pc from 'playcanvas';\nimport { CharacterManager } from './characters/CharacterManager';\nimport { CombatSystem } from './combat/CombatSystem';\n// Integrate with existing PlayCanvas script-based managers under src/scripts\nimport { StageManager } from './stages/StageManager';\nimport { InputManager } from './input/InputManager';\nimport { UIManager } from './ui/UIManager';\n// (Optional) Asset loader integration available under scripts if needed\nimport { Logger } from './utils/Logger';\n\nexport class GameEngine {\n  private app: pc.Application;\n  private characterManager: CharacterManager;\n  private combatSystem: CombatSystem;\n  private stageManager: StageManager;\n  private inputManager: InputManager;\n  private uiManager: UIManager;\n  // private assetManager: any;\n  private isInitialized = false;\n  private updateHandler: ((dt: number) => void) | null = null;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this.app = new pc.Application(canvas, {\n      mouse: new pc.Mouse(canvas),\n      touch: new pc.TouchDevice(canvas),\n      keyboard: new pc.Keyboard(window),\n      gamepads: new pc.GamePads()\n    });\n\n    this.setupApplication();\n    this.initializeManagers();\n  }\n\n  private setupApplication(): void {\n    this.app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\n    this.app.setCanvasResolution(pc.RESOLUTION_AUTO);\n    \n    window.addEventListener('resize', () => this.app.resizeCanvas());\n    \n    Logger.info('PlayCanvas application initialized');\n  }\n\n  private initializeManagers(): void {\n    // Asset loading can be handled later via script components\n    this.inputManager = new InputManager(this.app);\n    // Audio handled by PlayCanvas components or a future wrapper\n    this.characterManager = new CharacterManager(this.app);\n    this.combatSystem = new CombatSystem(this.app);\n    this.stageManager = new StageManager(this.app);\n    this.uiManager = new UIManager(this.app);\n  }\n\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      Logger.info('Initializing game systems...');\n      \n      // Preload assets if needed using AssetLoader script\n      await this.characterManager.initialize();\n      // StageManager/UIManager initialize through their own methods if needed\n      await this.stageManager.initialize();\n      await this.uiManager.initialize();\n      \n      this.combatSystem.initialize(this.characterManager, this.inputManager);\n      \n      this.isInitialized = true;\n      this.app.start();\n\n      // Wire main update loop\n      this.updateHandler = (dt: number) => {\n        this.inputManager.update();\n        this.characterManager.update(dt);\n        this.combatSystem.update(dt);\n      };\n      this.app.on('update', this.updateHandler);\n      \n      Logger.info('Game engine fully initialized');\n    } catch (error) {\n      Logger.error('Failed to initialize game engine:', error);\n      throw error;\n    }\n  }\n\n  public getApp(): pc.Application {\n    return this.app;\n  }\n\n  public getCharacterManager(): CharacterManager {\n    return this.characterManager;\n  }\n\n  public getCombatSystem(): CombatSystem {\n    return this.combatSystem;\n  }\n\n  public destroy(): void {\n    if (this.updateHandler) {\n      this.app.off('update', this.updateHandler);\n      this.updateHandler = null;\n    }\n    this.app.destroy();\n    Logger.info('Game engine destroyed');\n  }\n}\n", "\nimport * as pc from 'playcanvas';\nimport { Character, CharacterConfig } from '../../../types/character';\nimport { Logger } from '../utils/Logger';\n\nexport class CharacterManager {\n  private app: pc.Application;\n  private characters = new Map<string, Character>();\n  private characterConfigs = new Map<string, CharacterConfig>();\n  private activeCharacters: Character[] = [];\n\n  constructor(app: pc.Application) {\n    this.app = app;\n  }\n\n  public async initialize(): Promise<void> {\n    await this.loadCharacterConfigs();\n    Logger.info('Character manager initialized');\n  }\n\n  private async loadCharacterConfigs(): Promise<void> {\n    // Prefer a consolidated database file if available\n    try {\n      const dbResponse = await fetch('/data/characters_db.json');\n      if (dbResponse.ok) {\n        const db = await dbResponse.json();\n        const keys = Object.keys(db);\n        for (const key of keys) {\n          const normalized = this.normalizeCharacterConfig(db[key] as CharacterConfig);\n          this.characterConfigs.set(key, normalized);\n        }\n        Logger.info(`Loaded ${keys.length} characters from consolidated database`);\n        return;\n      }\n    } catch (e) {\n      Logger.warn('Consolidated character database not found; falling back to individual files');\n    }\n\n    // Fallback to individual files\n    const characterNames = ['ryu', 'ken', 'chun_li', 'sagat', 'zangief'];\n    for (const name of characterNames) {\n      try {\n        const response = await fetch(`/data/characters/${name}.json`);\n        const rawConfig: CharacterConfig = await response.json();\n        const config = this.normalizeCharacterConfig(rawConfig);\n        this.characterConfigs.set(name, config);\n        Logger.info(`Loaded character config: ${name}`);\n      } catch (error) {\n        Logger.error(`Failed to load character ${name}:`, error);\n      }\n    }\n  }\n\n  private normalizeCharacterConfig(config: CharacterConfig): CharacterConfig {\n    // Ensure stats exist with required fields using top-level fallbacks\n    const normalizedStats = {\n      health: (config as any).stats?.health ?? (config as any).health ?? 1000,\n      walkSpeed: (config as any).stats?.walkSpeed ?? (config as any).walkSpeed ?? 2\n    } as any;\n\n    // Flatten nested move groups like { moves: { normals: { ... }, specials: { ... } } }\n    let flattenedMoves: Record<string, any> | undefined = undefined;\n    const movesAny = (config as any).moves as any;\n    if (movesAny && typeof movesAny === 'object') {\n      const groups = ['normals', 'specials', 'supers', 'throws', 'unique'];\n      flattenedMoves = {};\n      for (const key of Object.keys(movesAny)) {\n        if (groups.includes(key) && movesAny[key] && typeof movesAny[key] === 'object') {\n          Object.assign(flattenedMoves, movesAny[key]);\n        } else if (movesAny[key] && typeof movesAny[key] === 'object') {\n          // Top-level moves already\n          flattenedMoves[key] = movesAny[key];\n        }\n      }\n    }\n\n    const normalized = {\n      ...config,\n      stats: normalizedStats,\n      moves: flattenedMoves ?? (config as any).moves\n    } as CharacterConfig as any;\n\n    return normalized;\n  }\n\n  public createCharacter(characterId: string, position: pc.Vec3): Character | null {\n    const config = this.characterConfigs.get(characterId);\n    if (!config) {\n      Logger.error(`Character config not found: ${characterId}`);\n      return null;\n    }\n\n    const characterEntity = new pc.Entity(characterId);\n    characterEntity.setPosition(position);\n    \n    const character: Character = {\n      id: characterId,\n      entity: characterEntity,\n      config: config,\n      health: config.stats.health,\n      meter: 0,\n      state: 'idle',\n      currentMove: null,\n      frameData: {\n        startup: 0,\n        active: 0,\n        recovery: 0,\n        advantage: 0\n      }\n    };\n\n    this.characters.set(characterId, character);\n    this.app.root.addChild(characterEntity);\n    \n    Logger.info(`Created character: ${characterId}`);\n    return character;\n  }\n\n  public getCharacter(characterId: string): Character | undefined {\n    return this.characters.get(characterId);\n  }\n\n  public setActiveCharacters(player1Id: string, player2Id: string): void {\n    const p1 = this.characters.get(player1Id);\n    const p2 = this.characters.get(player2Id);\n    \n    if (p1 && p2) {\n      this.activeCharacters = [p1, p2];\n      Logger.info(`Active characters set: ${player1Id} vs ${player2Id}`);\n    }\n  }\n\n  public getActiveCharacters(): Character[] {\n    return this.activeCharacters;\n  }\n\n  public update(deltaTime: number): void {\n    for (const character of this.activeCharacters) {\n      this.updateCharacterState(character, deltaTime);\n    }\n  }\n\n  private updateCharacterState(character: Character, deltaTime: number): void {\n    // Update character animation, physics, and state\n    // This will be expanded based on your specific needs\n  }\n\n  public getAvailableCharacters(): string[] {\n    return Array.from(this.characterConfigs.keys());\n  }\n}\n", "\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3\n}\n\nexport class Logger {\n  private static logLevel: LogLevel = LogLevel.INFO;\n  private static prefix = '[SF3]';\n\n  public static setLogLevel(level: LogLevel): void {\n    this.logLevel = level;\n  }\n\n  public static debug(message: string, ...args: any[]): void {\n    if (this.logLevel <= LogLevel.DEBUG) {\n      console.debug(`${this.prefix}[DEBUG]`, message, ...args);\n    }\n  }\n\n  public static info(message: string, ...args: any[]): void {\n    if (this.logLevel <= LogLevel.INFO) {\n      console.info(`${this.prefix}[INFO]`, message, ...args);\n    }\n  }\n\n  public static warn(message: string, ...args: any[]): void {\n    if (this.logLevel <= LogLevel.WARN) {\n      console.warn(`${this.prefix}[WARN]`, message, ...args);\n    }\n  }\n\n  public static error(message: string, ...args: any[]): void {\n    if (this.logLevel <= LogLevel.ERROR) {\n      console.error(`${this.prefix}[ERROR]`, message, ...args);\n    }\n  }\n}\n", "\nimport * as pc from 'playcanvas';\nimport { Character } from '../../../types/character';\nimport { CharacterManager } from '../characters/CharacterManager';\nimport { InputManager } from '../input/InputManager';\nimport { Logger } from '../utils/Logger';\n\ninterface HitResult {\n  hit: boolean;\n  damage: number;\n  knockback: pc.Vec3;\n  hitstun: number;\n  blockstun: number;\n}\n\nexport class CombatSystem {\n  private app: pc.Application;\n  private characterManager!: CharacterManager;\n  private inputManager!: InputManager;\n  private frameCounter = 0;\n  private hitstop = 0;\n\n  constructor(app: pc.Application) {\n    this.app = app;\n  }\n\n  public initialize(characterManager: CharacterManager, inputManager: InputManager): void {\n    this.characterManager = characterManager;\n    this.inputManager = inputManager;\n    Logger.info('Combat system initialized');\n  }\n\n  public update(deltaTime: number): void {\n    if (this.hitstop > 0) {\n      this.hitstop--;\n      return; // Skip frame during hitstop\n    }\n\n    this.frameCounter++;\n    this.processInputs();\n    this.updateHitboxes();\n    this.checkCollisions();\n  }\n\n  private processInputs(): void {\n    const activeCharacters = this.characterManager.getActiveCharacters();\n    \n    for (let i = 0; i < activeCharacters.length; i++) {\n      const character = activeCharacters[i];\n      const inputs = this.inputManager.getPlayerInputs(i);\n      \n      this.processCharacterInputs(character, inputs);\n    }\n  }\n\n  private processCharacterInputs(character: Character, inputs: any): void {\n    if (character.state !== 'idle' && character.state !== 'walking') {\n      return; // Character is in an active state\n    }\n\n    // Process movement\n    if (inputs.left) {\n      this.moveCharacter(character, -1);\n    } else if (inputs.right) {\n      this.moveCharacter(character, 1);\n    }\n\n    // Process attacks\n    if (inputs.lightPunch) {\n      this.executeMove(character, 'lightPunch');\n    } else if (inputs.mediumPunch) {\n      this.executeMove(character, 'mediumPunch');\n    } else if (inputs.heavyPunch) {\n      this.executeMove(character, 'heavyPunch');\n    }\n\n    // Process special moves (simplified motion detection)\n    if (inputs.hadoken) {\n      this.executeMove(character, 'hadoken');\n    }\n  }\n\n  private moveCharacter(character: Character, direction: number): void {\n    const walkSpeed = character.config.stats.walkSpeed;\n    const currentPos = character.entity.getPosition();\n    \n    currentPos.x += direction * walkSpeed * (1/60); // Assuming 60fps\n    character.entity.setPosition(currentPos);\n    \n    character.state = 'walking';\n  }\n\n  private executeMove(character: Character, moveName: string): void {\n    const moveData = character.config.moves[moveName];\n    if (!moveData) {\n      Logger.warn(`Move not found: ${moveName} for character ${character.id}`);\n      return;\n    }\n\n    character.currentMove = {\n      name: moveName,\n      data: moveData,\n      currentFrame: 0,\n      phase: 'startup'\n    };\n\n    character.state = 'attacking';\n    character.frameData = {\n      startup: moveData.startupFrames,\n      active: moveData.activeFrames,\n      recovery: moveData.recoveryFrames,\n      advantage: moveData.advantage || 0\n    };\n\n    Logger.info(`${character.id} executing ${moveName}`);\n  }\n\n  private updateHitboxes(): void {\n    const activeCharacters = this.characterManager.getActiveCharacters();\n    \n    for (const character of activeCharacters) {\n      if (character.currentMove) {\n        this.updateMoveFrames(character);\n      }\n    }\n  }\n\n  private updateMoveFrames(character: Character): void {\n    if (!character.currentMove) return;\n\n    character.currentMove.currentFrame++;\n    const move = character.currentMove;\n    const frameData = character.frameData;\n\n    if (move.currentFrame <= frameData.startup) {\n      move.phase = 'startup';\n    } else if (move.currentFrame <= frameData.startup + frameData.active) {\n      move.phase = 'active';\n    } else if (move.currentFrame <= frameData.startup + frameData.active + frameData.recovery) {\n      move.phase = 'recovery';\n    } else {\n      // Move finished\n      character.currentMove = null;\n      character.state = 'idle';\n    }\n  }\n\n  private checkCollisions(): void {\n    const activeCharacters = this.characterManager.getActiveCharacters();\n    \n    if (activeCharacters.length !== 2) return;\n\n    const [p1, p2] = activeCharacters;\n    \n    if (p1.currentMove?.phase === 'active' && this.charactersColliding(p1, p2)) {\n      this.processHit(p1, p2);\n    } else if (p2.currentMove?.phase === 'active' && this.charactersColliding(p2, p1)) {\n      this.processHit(p2, p1);\n    }\n  }\n\n  private charactersColliding(attacker: Character, defender: Character): boolean {\n    const attackerPos = attacker.entity.getPosition();\n    const defenderPos = defender.entity.getPosition();\n    const distance = attackerPos.distance(defenderPos);\n    \n    // Simple collision detection - should be replaced with proper hitbox system\n    return distance < 2.0;\n  }\n\n  private processHit(attacker: Character, defender: Character): void {\n    if (!attacker.currentMove) return;\n\n    const moveData = attacker.currentMove.data;\n    const damage = moveData.damage;\n    \n    defender.health = Math.max(0, defender.health - damage);\n    this.hitstop = Math.floor(damage / 10); // Hitstop based on damage\n    \n    Logger.info(`${attacker.id} hits ${defender.id} for ${damage} damage`);\n    \n    if (defender.health <= 0) {\n      this.handleKO(defender, attacker);\n    }\n  }\n\n  private handleKO(ko: Character, winner: Character): void {\n    ko.state = 'ko';\n    Logger.info(`${ko.id} is KO'd! ${winner.id} wins!`);\n    \n    // Trigger victory sequence\n    this.app.fire('match:victory', winner.id);\n  }\n\n  public getCurrentFrame(): number {\n    return this.frameCounter;\n  }\n\n  public isInHistop(): boolean {\n    return this.hitstop > 0;\n  }\n}\n", "import * as pc from 'playcanvas';\n\nexport class StageManager {\n  private app: pc.Application;\n\n  constructor(app: pc.Application) {\n    this.app = app;\n  }\n\n  public async initialize(): Promise<void> {\n    // Camera\n    const camera = new pc.Entity('MainCamera');\n    camera.addComponent('camera', {\n      clearColor: new pc.Color(0, 0, 0),\n      fov: 55,\n      nearClip: 0.1,\n      farClip: 1000\n    });\n    camera.setPosition(0, 2, 10);\n    camera.lookAt(0, 1, 0);\n    this.app.root.addChild(camera);\n\n    // Light\n    const light = new pc.Entity('DirectionalLight');\n    light.addComponent('light', {\n      type: pc.LIGHTTYPE_DIRECTIONAL,\n      color: new pc.Color(1, 1, 1),\n      intensity: 1.0,\n      castShadows: false\n    });\n    light.setEulerAngles(45, 30, 0);\n    this.app.root.addChild(light);\n\n    // Test cube\n    const box = new pc.Entity('TestBox');\n    box.addComponent('model', { type: 'box' });\n    box.setPosition(0, 0.5, 0);\n    this.app.root.addChild(box);\n  }\n}\n\n", "\nimport * as pc from 'playcanvas';\n\nexport interface PlayerInputs {\n  up: boolean;\n  down: boolean;\n  left: boolean;\n  right: boolean;\n  lightPunch: boolean;\n  mediumPunch: boolean;\n  heavyPunch: boolean;\n  lightKick: boolean;\n  mediumKick: boolean;\n  heavyKick: boolean;\n  hadoken: boolean;\n  shoryuken: boolean;\n  tatsumaki: boolean;\n}\n\nexport class InputManager {\n  private app: pc.Application;\n  private player1Inputs: PlayerInputs;\n  private player2Inputs: PlayerInputs;\n  private keyboard: pc.Keyboard;\n  private gamepads: pc.GamePads;\n\n  constructor(app: pc.Application) {\n    this.app = app;\n    this.keyboard = app.keyboard;\n    this.gamepads = app.gamepads;\n    \n    this.player1Inputs = this.createEmptyInputs();\n    this.player2Inputs = this.createEmptyInputs();\n    \n    this.setupKeyboardBindings();\n  }\n\n  private createEmptyInputs(): PlayerInputs {\n    return {\n      up: false,\n      down: false,\n      left: false,\n      right: false,\n      lightPunch: false,\n      mediumPunch: false,\n      heavyPunch: false,\n      lightKick: false,\n      mediumKick: false,\n      heavyKick: false,\n      hadoken: false,\n      shoryuken: false,\n      tatsumaki: false\n    };\n  }\n\n  private setupKeyboardBindings(): void {\n    // Player 1 controls (WASD + keys)\n    this.keyboard.on('keydown', (e) => {\n      switch (e.key.toLowerCase()) {\n        case 'w': this.player1Inputs.up = true; break;\n        case 's': this.player1Inputs.down = true; break;\n        case 'a': this.player1Inputs.left = true; break;\n        case 'd': this.player1Inputs.right = true; break;\n        case 'u': this.player1Inputs.lightPunch = true; break;\n        case 'i': this.player1Inputs.mediumPunch = true; break;\n        case 'o': this.player1Inputs.heavyPunch = true; break;\n        case 'j': this.player1Inputs.lightKick = true; break;\n        case 'k': this.player1Inputs.mediumKick = true; break;\n        case 'l': this.player1Inputs.heavyKick = true; break;\n      }\n    });\n\n    this.keyboard.on('keyup', (e) => {\n      switch (e.key.toLowerCase()) {\n        case 'w': this.player1Inputs.up = false; break;\n        case 's': this.player1Inputs.down = false; break;\n        case 'a': this.player1Inputs.left = false; break;\n        case 'd': this.player1Inputs.right = false; break;\n        case 'u': this.player1Inputs.lightPunch = false; break;\n        case 'i': this.player1Inputs.mediumPunch = false; break;\n        case 'o': this.player1Inputs.heavyPunch = false; break;\n        case 'j': this.player1Inputs.lightKick = false; break;\n        case 'k': this.player1Inputs.mediumKick = false; break;\n        case 'l': this.player1Inputs.heavyKick = false; break;\n      }\n    });\n  }\n\n  public getPlayerInputs(playerIndex: number): PlayerInputs {\n    return playerIndex === 0 ? this.player1Inputs : this.player2Inputs;\n  }\n\n  public update(): void {\n    // Update gamepad inputs if connected\n    this.updateGamepadInputs();\n    \n    // Update special move detection\n    this.updateSpecialMoves();\n  }\n\n  private updateGamepadInputs(): void {\n    const pads = this.gamepads.poll();\n    const gamepad = pads[0];\n    if (gamepad) {\n      // Map gamepad inputs to player 1\n      this.player1Inputs.left = gamepad.isPressed(pc.PAD_L_STICK_BUTTON) || gamepad.isPressed(pc.PAD_LEFT);\n      this.player1Inputs.right = gamepad.isPressed(pc.PAD_RIGHT);\n      this.player1Inputs.up = gamepad.isPressed(pc.PAD_UP);\n      this.player1Inputs.down = gamepad.isPressed(pc.PAD_DOWN);\n\n      this.player1Inputs.lightPunch = gamepad.isPressed(pc.PAD_FACE_1);\n      this.player1Inputs.mediumPunch = gamepad.isPressed(pc.PAD_FACE_2);\n      this.player1Inputs.heavyPunch = gamepad.isPressed(pc.PAD_R_SHOULDER_1);\n      this.player1Inputs.lightKick = gamepad.isPressed(pc.PAD_FACE_3);\n      this.player1Inputs.mediumKick = gamepad.isPressed(pc.PAD_FACE_4);\n      this.player1Inputs.heavyKick = gamepad.isPressed(pc.PAD_R_SHOULDER_2);\n    }\n  }\n\n  private updateSpecialMoves(): void {\n    // Simple special move detection (should be expanded with proper motion buffer)\n    this.player1Inputs.hadoken = this.detectHadoken(this.player1Inputs);\n    this.player2Inputs.hadoken = this.detectHadoken(this.player2Inputs);\n  }\n\n  private detectHadoken(inputs: PlayerInputs): boolean {\n    // Simplified hadoken detection (down -> forward + punch)\n    return inputs.down && inputs.right && inputs.lightPunch;\n  }\n}\n", "import * as pc from 'playcanvas';\n\nexport class UIManager {\n  private app: pc.Application;\n\n  constructor(app: pc.Application) {\n    this.app = app;\n  }\n\n  public async initialize(): Promise<void> {\n    // Minimal UI init for core engine\n  }\n}\n\n"],
  "mappings": "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",
  "names": ["pc", "pc", "pc", "pc"]
}
